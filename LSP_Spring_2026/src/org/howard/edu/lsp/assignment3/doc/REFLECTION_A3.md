Reflection: Assignment 2 vs. Assignment 3
Author: Saleh A.

Course: Large Scale Programming

Date: February 20, 2026

1. Design Differences
The primary difference between Assignment 2 and Assignment 3 is the move from Procedural Programming to Object-Oriented Programming (OOP).

Assignment 2 (Procedural): The logic was likely contained within a single main method or a few static helper methods. Data was handled as raw strings or arrays, and the flow of the program was a linear sequence of "Read -> Transform -> Write" all in one place.

Assignment 3 (Object-Oriented): The program is now decomposed into four distinct classes. Data is no longer just a "line in a file"; it is a Product object with its own state and behavior.

2. Object-Oriented Ideas Used
Objects and Classes
I created a Product class to serve as a blueprint. Every row in the products.csv file is now instantiated as a unique Product object. This allows the program to treat data as a collection of entities rather than a collection of strings.

Encapsulation
In Assignment 3, I made the fields in the Product class (id, name, price, category) private. They can only be accessed or modified through public getters and setters. This protects the integrity of the data and ensures that transformations happen through controlled methods.

Single Responsibility Principle (SRP)
Each class now has exactly one job:

CSVService: Only handles the "how" of reading/writing files.

ProductTransformer: Only handles the "what" of changing the data.

Product: Only handles the representation of the data.

ProductManager: Only handles the coordination (orchestration) of the workflow.

Abstraction
The ProductManager uses the CSVService without needing to know that it uses a BufferedReader or a PrintWriter internally. It simply calls readProducts(), abstracting away the low-level details of file I/O.

3. Testing and Verification
To ensure that Assignment 3 meets the exact requirements of Assignment 2, I performed the following tests:

Output Parity Test: I ran both versions of the program using the same products.csv. I used a text comparison tool to verify that the transformed_products.csv generated by Assignment 3 was identical to the one from Assignment 2.

Relative Path Verification: I confirmed that the program correctly identifies the data/ folder at the project root, ensuring it doesn't break when moved between environments.

Error Handling: I tested the program with a missing products.csv file and a malformed CSV (missing columns). I verified that the try-catch blocks in ProductManager caught these exceptions and printed user-friendly error messages, matching the behavior required in the previous assignment.

4. Conclusion
By refactoring the code into an OO design, the system is now much easier to maintain. If the client decides to change the transformation logic (e.g., changing the discount rate), I only need to modify the ProductTransformer class without touching the file-reading logic or the main driver.